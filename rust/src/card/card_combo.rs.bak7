use godot::prelude::*;
use super::card::CardData;
use std::collections::HashMap;

/// Resource type enum (matches GDScript ResourceLedger.R enum)
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ResourceType {
    Gold = 0,    // Diamonds
    Food = 1,    // Hearts
    Labor = 2,   // Spades
    Faith = 3,   // Clubs
}

impl ResourceType {
    /// Get resource type from suit (0=Clubs, 1=Diamonds, 2=Hearts, 3=Spades)
    pub fn from_suit(suit: u8) -> Self {
        match suit {
            0 => ResourceType::Faith,   // Clubs -> Faith
            1 => ResourceType::Gold,    // Diamonds -> Gold
            2 => ResourceType::Food,    // Hearts -> Food
            3 => ResourceType::Labor,   // Spades -> Labor
            _ => ResourceType::Gold,    // Default to Gold
        }
    }

    pub fn to_string(&self) -> String {
        match self {
            ResourceType::Gold => "Gold".to_string(),
            ResourceType::Food => "Food".to_string(),
            ResourceType::Labor => "Labor".to_string(),
            ResourceType::Faith => "Faith".to_string(),
        }
    }
}

/// Resource bonus from a combo
#[derive(Debug, Clone)]
pub struct ResourceBonus {
    pub resource_type: ResourceType,
    pub resource_name: String,
    pub amount: f32,
}

/// Poker hand ranks (from weakest to strongest)
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum PokerHand {
    HighCard = 0,
    OnePair = 1,
    TwoPair = 2,
    ThreeOfAKind = 3,
    Straight = 4,
    Flush = 5,
    FullHouse = 6,
    FourOfAKind = 7,
    StraightFlush = 8,
    RoyalFlush = 9,
}

impl PokerHand {
    pub fn to_string(&self) -> String {
        match self {
            PokerHand::HighCard => "High Card".to_string(),
            PokerHand::OnePair => "One Pair".to_string(),
            PokerHand::TwoPair => "Two Pair".to_string(),
            PokerHand::ThreeOfAKind => "Three of a Kind".to_string(),
            PokerHand::Straight => "Straight".to_string(),
            PokerHand::Flush => "Flush".to_string(),
            PokerHand::FullHouse => "Full House".to_string(),
            PokerHand::FourOfAKind => "Four of a Kind".to_string(),
            PokerHand::StraightFlush => "Straight Flush".to_string(),
            PokerHand::RoyalFlush => "Royal Flush".to_string(),
        }
    }

    /// Get bonus multiplier for this hand
    pub fn bonus_multiplier(&self) -> f32 {
        match self {
            PokerHand::HighCard => 1.0,
            PokerHand::OnePair => 1.5,
            PokerHand::TwoPair => 2.0,
            PokerHand::ThreeOfAKind => 3.0,
            PokerHand::Straight => 4.0,
            PokerHand::Flush => 5.0,
            PokerHand::FullHouse => 7.0,
            PokerHand::FourOfAKind => 10.0,
            PokerHand::StraightFlush => 20.0,
            PokerHand::RoyalFlush => 50.0,
        }
    }
}

/// Card with position on hex grid
#[derive(Debug, Clone)]
pub struct PositionedCard {
    pub card: CardData,
    pub x: i32,
    pub y: i32,
    pub index: usize, // Original index in input array
}

/// Result of combo detection
#[derive(Debug, Clone)]
pub struct ComboResult {
    pub hand: PokerHand,
    pub hand_name: String,
    pub bonus_multiplier: f32,
    pub cards_used: Vec<usize>, // Indices of cards that form the combo
    pub positions: Vec<(i32, i32)>, // Hex positions of the combo
    pub resource_bonuses: Vec<ResourceBonus>, // Resource bonuses from this combo
}

impl ComboResult {
    pub fn new(hand: PokerHand) -> Self {
        Self {
            hand_name: hand.to_string(),
            bonus_multiplier: hand.bonus_multiplier(),
            hand,
            cards_used: Vec::new(),
            positions: Vec::new(),
            resource_bonuses: Vec::new(),
        }
    }

    pub fn with_cards(hand: PokerHand, cards: Vec<usize>, positions: Vec<(i32, i32)>) -> Self {
        Self {
            hand_name: hand.to_string(),
            bonus_multiplier: hand.bonus_multiplier(),
            hand,
            cards_used: cards,
            resource_bonuses: Vec::new(),
            positions,
        }
    }

    pub fn with_resources(hand: PokerHand, cards: Vec<usize>, positions: Vec<(i32, i32)>, line_cards: &[&CardData]) -> Self {
        let mut result = Self {
            hand_name: hand.to_string(),
            bonus_multiplier: hand.bonus_multiplier(),
            hand,
            cards_used: cards,
            positions,
            resource_bonuses: Vec::new(),
        };
        result.calculate_resource_bonuses(line_cards);
        result
    }

    fn calculate_resource_bonuses(&mut self, cards: &[&CardData]) {
        let mut suit_counts: HashMap<u8, usize> = HashMap::new();
        for card in cards.iter().filter(|c| !c.is_custom) {
            *suit_counts.entry(card.suit).or_insert(0) += 1;
        }
        let base_amount = 10.0;
        for (suit, count) in suit_counts.iter() {
            let resource_type = ResourceType::from_suit(*suit);
            let amount = base_amount * (*count as f32) * self.bonus_multiplier;
            self.resource_bonuses.push(ResourceBonus {
                resource_type,
                resource_name: resource_type.to_string(),
                amount,
            });
        }
    }
}

/// Hex grid directions (6 directions for flat-top hex)
const HEX_DIRECTIONS: [(i32, i32); 6] = [
    (1, 0),   // East
    (1, -1),  // Northeast
    (0, -1),  // Northwest
    (-1, 0),  // West
    (-1, 1),  // Southwest
    (0, 1),   // Southeast
];

/// Detect poker hands in hex grid lines
pub struct ComboDetector;

impl ComboDetector {
    /// Detect the best poker hand from positioned cards on hex grid
    /// Cards must be in a straight line, jokers (custom cards) can be skipped
    pub fn detect_combo(positioned_cards: &[PositionedCard]) -> ComboResult {
        if positioned_cards.is_empty() {
            return ComboResult::new(PokerHand::HighCard);
        }

        // Find all possible straight lines through the cards
        let lines = Self::find_all_lines(positioned_cards);

        // Check each line for the best hand
        let mut best_result = ComboResult::new(PokerHand::HighCard);

        for line in lines {
            if let Some(result) = Self::check_line_for_combos(&line, positioned_cards) {
                if result.hand > best_result.hand {
                    best_result = result;
                }
            }
        }

        best_result
    }

    /// Find all straight lines of 5+ cards (including jokers)
    fn find_all_lines(cards: &[PositionedCard]) -> Vec<Vec<usize>> {
        let mut lines = Vec::new();

        // Try starting from each card
        for (start_idx, start_card) in cards.iter().enumerate() {
            // Try each of the 6 hex directions
            for direction in &HEX_DIRECTIONS {
                if let Some(line) = Self::trace_line(start_idx, *direction, cards) {
                    if line.len() >= 5 {
                        // Check if this line already exists (might have found it from other direction)
                        if !Self::line_exists(&line, &lines) {
                            lines.push(line);
                        }
                    }
                }
            }
        }

        lines
    }

    /// Trace a line in a specific direction from a starting card
    fn trace_line(start_idx: usize, direction: (i32, i32), cards: &[PositionedCard]) -> Option<Vec<usize>> {
        let start = &cards[start_idx];
        let mut line = vec![start_idx];
        let mut current_pos = (start.x, start.y);

        // Trace forward
        loop {
            let next_pos = (current_pos.0 + direction.0, current_pos.1 + direction.1);

            if let Some(next_idx) = Self::find_card_at_position(&next_pos, cards) {
                line.push(next_idx);
                current_pos = next_pos;
            } else {
                break;
            }
        }

        // Trace backward
        current_pos = (start.x, start.y);
        let reverse_dir = (-direction.0, -direction.1);
        loop {
            let prev_pos = (current_pos.0 + reverse_dir.0, current_pos.1 + reverse_dir.1);

            if let Some(prev_idx) = Self::find_card_at_position(&prev_pos, cards) {
                line.insert(0, prev_idx);
                current_pos = prev_pos;
            } else {
                break;
            }
        }

        if line.len() >= 2 {
            Some(line)
        } else {
            None
        }
    }

    /// Find card index at specific position
    fn find_card_at_position(pos: &(i32, i32), cards: &[PositionedCard]) -> Option<usize> {
        cards.iter()
            .position(|c| c.x == pos.0 && c.y == pos.1)
    }

    /// Check if line already exists in the list
    fn line_exists(line: &[usize], lines: &[Vec<usize>]) -> bool {
        for existing in lines {
            if Self::same_line(line, existing) {
                return true;
            }
        }
        false
    }

    /// Check if two lines contain the same cards (regardless of order)
    fn same_line(a: &[usize], b: &[usize]) -> bool {
        if a.len() != b.len() {
            return false;
        }
        let mut a_sorted = a.to_vec();
        let mut b_sorted = b.to_vec();
        a_sorted.sort();
        b_sorted.sort();
        a_sorted == b_sorted
    }

    /// Check a line for poker combos (skipping jokers)
    fn check_line_for_combos(line: &[usize], all_cards: &[PositionedCard]) -> Option<ComboResult> {
        // Extract standard cards from line (skip jokers/custom cards)
        let line_cards: Vec<&CardData> = line.iter()
            .map(|&idx| &all_cards[idx].card)
            .filter(|c| !c.is_custom)
            .collect();

        if line_cards.len() < 5 {
            return None;
        }

        // Check for hands (from strongest to weakest)
        if let Some(_) = Self::check_royal_flush(&line_cards) {
            let positions: Vec<(i32, i32)> = line.iter().map(|&idx| (all_cards[idx].x, all_cards[idx].y)).collect();
            return Some(ComboResult::with_resources(PokerHand::RoyalFlush, line.to_vec(), positions, &line_cards));
        }

        if let Some(_) = Self::check_straight_flush(&line_cards) {
            let positions: Vec<(i32, i32)> = line.iter().map(|&idx| (all_cards[idx].x, all_cards[idx].y)).collect();
            return Some(ComboResult::with_resources(PokerHand::StraightFlush, line.to_vec(), positions, &line_cards));
        }

        if let Some(_) = Self::check_four_of_a_kind(&line_cards) {
            let positions: Vec<(i32, i32)> = line.iter().map(|&idx| (all_cards[idx].x, all_cards[idx].y)).collect();
            return Some(ComboResult::with_resources(PokerHand::FourOfAKind, line.to_vec(), positions, &line_cards));
        }

        if let Some(_) = Self::check_full_house(&line_cards) {
            let positions: Vec<(i32, i32)> = line.iter().map(|&idx| (all_cards[idx].x, all_cards[idx].y)).collect();
            return Some(ComboResult::with_resources(PokerHand::FullHouse, line.to_vec(), positions, &line_cards));
        }

        if let Some(_) = Self::check_flush(&line_cards) {
            let positions: Vec<(i32, i32)> = line.iter().map(|&idx| (all_cards[idx].x, all_cards[idx].y)).collect();
            return Some(ComboResult::with_resources(PokerHand::Flush, line.to_vec(), positions, &line_cards));
        }

        if let Some(_) = Self::check_straight(&line_cards) {
            let positions: Vec<(i32, i32)> = line.iter().map(|&idx| (all_cards[idx].x, all_cards[idx].y)).collect();
            return Some(ComboResult::with_resources(PokerHand::Straight, line.to_vec(), positions, &line_cards));
        }

        if let Some(_) = Self::check_three_of_a_kind(&line_cards) {
            let positions: Vec<(i32, i32)> = line.iter().map(|&idx| (all_cards[idx].x, all_cards[idx].y)).collect();
            return Some(ComboResult::with_resources(PokerHand::ThreeOfAKind, line.to_vec(), positions, &line_cards));
        }

        if let Some(_) = Self::check_two_pair(&line_cards) {
            let positions: Vec<(i32, i32)> = line.iter().map(|&idx| (all_cards[idx].x, all_cards[idx].y)).collect();
            return Some(ComboResult::with_resources(PokerHand::TwoPair, line.to_vec(), positions, &line_cards));
        }

        if let Some(_) = Self::check_one_pair(&line_cards) {
            let positions: Vec<(i32, i32)> = line.iter().map(|&idx| (all_cards[idx].x, all_cards[idx].y)).collect();
            return Some(ComboResult::with_resources(PokerHand::OnePair, line.to_vec(), positions, &line_cards));
        }

        None
    }

    /// Count cards by value
    fn count_by_value(cards: &[&CardData]) -> HashMap<u8, usize> {
        let mut counts = HashMap::new();
        for card in cards {
            *counts.entry(card.value).or_insert(0) += 1;
        }
        counts
    }

    /// Count cards by suit
    fn count_by_suit(cards: &[&CardData]) -> HashMap<u8, usize> {
        let mut counts = HashMap::new();
        for card in cards {
            *counts.entry(card.suit).or_insert(0) += 1;
        }
        counts
    }

    // Poker hand checking functions (similar to before but simplified)

    fn check_royal_flush(cards: &[&CardData]) -> Option<()> {
        let by_suit = Self::count_by_suit(cards);
        for (_suit, count) in by_suit.iter() {
            if *count >= 5 {
                let values: Vec<u8> = cards.iter().map(|c| c.value).collect();
                if values.contains(&10) && values.contains(&11) && values.contains(&12)
                   && values.contains(&13) && values.contains(&1) {
                    return Some(());
                }
            }
        }
        None
    }

    fn check_straight_flush(cards: &[&CardData]) -> Option<()> {
        if Self::check_flush(cards).is_some() && Self::check_straight(cards).is_some() {
            return Some(());
        }
        None
    }

    fn check_four_of_a_kind(cards: &[&CardData]) -> Option<()> {
        let by_value = Self::count_by_value(cards);
        for (_value, count) in by_value.iter() {
            if *count == 4 {
                return Some(());
            }
        }
        None
    }

    fn check_full_house(cards: &[&CardData]) -> Option<()> {
        let by_value = Self::count_by_value(cards);
        let mut has_three = false;
        let mut has_pair = false;

        for (_value, count) in by_value.iter() {
            if *count == 3 {
                has_three = true;
            } else if *count == 2 {
                has_pair = true;
            }
        }

        if has_three && has_pair {
            Some(())
        } else {
            None
        }
    }

    fn check_flush(cards: &[&CardData]) -> Option<()> {
        let by_suit = Self::count_by_suit(cards);
        for (_suit, count) in by_suit.iter() {
            if *count >= 5 {
                return Some(());
            }
        }
        None
    }

    fn check_straight(cards: &[&CardData]) -> Option<()> {
        if cards.len() < 5 {
            return None;
        }

        let mut values: Vec<u8> = cards.iter().map(|c| c.value).collect();
        values.sort();
        values.dedup();

        if values.len() < 5 {
            return None;
        }

        // Check for consecutive values
        for window in values.windows(5) {
            let mut is_consecutive = true;
            for i in 0..4 {
                if window[i + 1] != window[i] + 1 {
                    is_consecutive = false;
                    break;
                }
            }
            if is_consecutive {
                return Some(());
            }
        }

        // Check for A-2-3-4-5 (Ace low straight)
        if values.contains(&1) && values.contains(&2) && values.contains(&3)
           && values.contains(&4) && values.contains(&5) {
            return Some(());
        }

        None
    }

    fn check_three_of_a_kind(cards: &[&CardData]) -> Option<()> {
        let by_value = Self::count_by_value(cards);
        for (_value, count) in by_value.iter() {
            if *count == 3 {
                return Some(());
            }
        }
        None
    }

    fn check_two_pair(cards: &[&CardData]) -> Option<()> {
        let by_value = Self::count_by_value(cards);
        let pairs = by_value.values().filter(|&&count| count == 2).count();
        if pairs >= 2 {
            Some(())
        } else {
            None
        }
    }

    fn check_one_pair(cards: &[&CardData]) -> Option<()> {
        let by_value = Self::count_by_value(cards);
        for (_value, count) in by_value.iter() {
            if *count == 2 {
                return Some(());
            }
        }
        None
    }
}

/// Godot-exposed combo detector
#[derive(GodotClass)]
#[class(base=RefCounted)]
pub struct CardComboDetector {
    base: Base<RefCounted>,
}

#[godot_api]
impl IRefCounted for CardComboDetector {
    fn init(base: Base<RefCounted>) -> Self {
        Self { base }
    }
}

#[godot_api]
impl CardComboDetector {
    /// Detect combo from array of card dictionaries WITH POSITIONS
    /// Each dict needs: ulid, suit, value, card_id, is_custom, x, y (hex position)
    /// Returns Dictionary with: hand_name, bonus_multiplier, card_indices, positions
    #[func]
    pub fn detect_combo_on_hex_grid(card_dicts: Array<Dictionary>) -> Dictionary {
        // Convert dictionaries to PositionedCards
        let positioned_cards: Vec<PositionedCard> = card_dicts
            .iter_shared()
            .enumerate()
            .filter_map(|(idx, dict)| Self::dict_to_positioned_card(&dict, idx))
            .collect();

        if positioned_cards.is_empty() {
            return Dictionary::new();
        }

        // Detect combo
        let result = ComboDetector::detect_combo(&positioned_cards);

        // Convert to dictionary
        let mut dict = Dictionary::new();
        dict.set("hand_name", result.hand_name);
        dict.set("bonus_multiplier", result.bonus_multiplier);
        dict.set("hand_rank", result.hand as i32);

        let mut indices_array = Array::<i32>::new();
        for idx in result.cards_used {
            indices_array.push(idx as i32);
        }
        dict.set("card_indices", indices_array);

        let mut positions_array = Array::<Dictionary>::new();
        for (x, y) in result.positions {
            let mut pos_dict = Dictionary::new();
            pos_dict.set("x", x);
            pos_dict.set("y", y);
            positions_array.push(&pos_dict);
        }
        dict.set("positions", positions_array);

        dict
    }

    /// Helper: Convert Godot Dictionary to PositionedCard
    fn dict_to_positioned_card(dict: &Dictionary, index: usize) -> Option<PositionedCard> {
        let ulid = dict.get("ulid")?.to::<PackedByteArray>();
        let suit = dict.get("suit")?.to::<u8>();
        let value = dict.get("value")?.to::<u8>();
        let card_id = dict.get("card_id")?.to::<i32>();
        let is_custom = dict.get("is_custom")?.to::<bool>();
        let x = dict.get("x")?.to::<i32>();
        let y = dict.get("y")?.to::<i32>();

        Some(PositionedCard {
            card: CardData {
                ulid: ulid.to_vec(),
                suit,
                value,
                card_id,
                is_custom,
                state: super::card::CardState::OnBoard,
                position: Some((x, y)),
                owner_id: None,
            },
            x,
            y,
            index,
        })
    }
}
